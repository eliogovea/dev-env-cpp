#pragma once

#include <algorithm>
#include <cassert>
#include <cstddef>
#include <numeric>
#include <utility>

template <typename Type, std::size_t Capacity>
    requires std::unsigned_integral<Type>  //
          && (0U < Capacity)               //
          && (Capacity - 1U <= std::numeric_limits<Type>::max())
class IndexCoordinator
{
   public:
    IndexCoordinator()
        : size_(0U)
    {
        std::iota(std::begin(value_), std::end(value_), 0U);
        std::iota(std::begin(where_), std::end(where_), 0U);
    }

    auto constexpr capacity() const noexcept -> std::size_t
    {
        return Capacity;
    }

    /// @brief number of used values
    auto size() const noexcept -> std::size_t
    {
        return size_;
    }

    /// @brief take one value
    /// @return one value in the range [0, Capacity)
    [[nodiscard]] auto take() -> Type
    {
        assert(size_ < Capacity);
        return value_[size_++];
    }

    /// @brief give `value` back
    /// @param value `value` was generated by `take()`
    auto give(Type value) -> void
    {
        assert(value < Capacity);

        assert(0U < size_);
        assert(where_[value] < size_);

        --size_;

        assert(value_[where_[value]] == value);
        assert(where_[value_[size_]] == size_);

        auto const lhs_value = value;
        auto const rhs_value = value_[size_];
        auto const lhs_where = where_[value];
        auto const rhs_where = size_;

        using std::swap;
        swap(where_[lhs_value], where_[rhs_value]);
        swap(value_[lhs_where], value_[rhs_where]);

        assert(value_[size_] == value);
        assert(where_[value] == size_);
    }

   private:
    std::size_t size_ = 0U;

    Type value_[Capacity];
    Type where_[Capacity];
};
